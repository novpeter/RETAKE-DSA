import javafx.util.Pair;import java.util.*;/** * Created by Petr on 18.04.2017. */public class Graph {    ArrayList<Vertex> vertices;    ArrayList<Edge> edges;    HashMap<String, Vertex> vertexMap;    HashMap<Pair<Vertex,Vertex>, Edge> edgeMap;    LinkedList<Vertex> queue;    ArrayList<Vertex> topOrder;    public Graph() {        edgeMap = new HashMap<>();        vertexMap= new HashMap<>();        edges = new ArrayList<>();        vertices = new ArrayList<>();    }    /**     * This method adds new edge to the edge list.     * @param start - start of edge     * @param end - end of edge     */    public void addEdge(String start, String end, String operation) {        if (vertexMap.containsKey(start) && vertexMap.containsKey(end) && !areAdjacent(start, end)) {            Vertex v1 = vertexMap.get(start);            Vertex v2 = vertexMap.get(end);            Edge edge = new Edge(v1, v2, operation);            edges.add(edge);            edgeMap.put(new Pair<>(v1, v2), edge);            v1.children.add(v2);            v2.parents.add(v1);        }    }    /**     * This method adds new vertex to the vertex list.     * @param name - name of the new vertex.     * @param i     */    public void addVertex(String name, int i) {        if (!vertexMap.containsKey(name)) {            Vertex vertex = new Vertex(name);            vertex.value = i;            vertexMap.put(name, vertex);            vertices.add(vertex);        }    }    /**     * This method adds new vertex to the vertex list.     * @param vertex - name of the new vertex.     */    public void addVertex(Vertex vertex) {        if (!vertexMap.containsKey(vertex.getName())) {            vertexMap.put(vertex.getName(), vertex);            vertices.add(vertex);        }    }    public boolean containVertex(String name){        try{            vertexMap.get(name);        }catch (NullPointerException e){            return false;        }        return true;    }    /**     * This method returns if two vertices are adjacent     * @param start vertex     * @param end vertex     * @return true/false     */    public boolean areAdjacent(Vertex start, Vertex end){        return edgeMap.containsKey(new Pair<>(start, end));    }    /**     * This method returns if two vertices are adjacent     * @param startName - name of start vertex     * @param endName - name of end vertex     * @return true/false     */    public boolean areAdjacent(String startName, String endName){        Vertex start = vertexMap.get(startName);        Vertex end = vertexMap.get(endName);        return edgeMap.containsKey(new Pair<>(start, end));    }    /**     * This method returns degree of the vertex     * @param v - given vertex     * @return degree     */    public int inDegree(Vertex v){        return v.parents.size();    }    /**     * This method returns degree of the vertex     * @param name  - name of the given vertex     * @return degree     */    public int inDegree(String name){        Vertex v = vertexMap.get(name);        return v.parents.size();    }    /**     * This method removes Vertex from the graph.     * @param v - given vertex     */    public void removeVertex(Vertex v){        vertexMap.remove(v.getName());        for (Vertex parent: v.parents) {            v.children.remove(v);            edges.remove(edgeMap.remove(new Pair<>(parent, v)));        }        for (Vertex child: v.children) {            v.parents.remove(v);            edges.remove(edgeMap.remove(new Pair<>(v, child)));        }        vertices.remove(v);    }    /**     * This method removes Vertex from the graph, also removes this vertex form every "adjacencyVertex" list.     * @param name - name of the given vertex     */    public void removeVertex(String name){        Vertex v = vertexMap.get(name);        vertexMap.remove(name);        for (Vertex parent: v.parents) {            v.children.remove(v);            edges.remove(edgeMap.remove(new Pair<>(parent, v)));        }        for (Vertex child: v.children) {            v.parents.remove(v);            edges.remove(edgeMap.remove(new Pair<>(v, child)));        }        vertices.remove(v);    }    /**     * This method removes Edge from the graph, also removes this edge from every "incidentEdge" lists     * @param e - given edge     */    public void removeEdge(Edge e){        e.getEndVertex().parents.remove(e.getEndVertex());        e.getStartVertex().children.remove(e.getStartVertex());        edges.remove(new Pair<>(e.getStartVertex(), e.getEndVertex()));        edges.remove(e);    }    /**     * This method returns the value of "R" after using topological sort.     * @return value of "R"     */    public String solveSystem(){        topOrder = new ArrayList<>();        queue = new LinkedList<>();        topSort();        if (topOrder.contains(vertexMap.get("R"))){            for (int i = 0; i < topOrder.size(); i++) {                Vertex vertex = topOrder.get(i);                if (vertex.parents.size()>0){                    Vertex v1 = vertex.parents.get(0);                    Vertex v2 = vertex.parents.get(1);                    int value1 = v1.value;                    int value2 = v2.value;                    if (edgeMap.containsKey(new Pair<>(v1, vertex)) && edgeMap.containsKey(new Pair<>(v2, vertex))){                        Edge e = edgeMap.get(new Pair<>(v1, vertex));                        if (e.getOperation().equals("*")){                            vertex.value = value1 * value2;                        }                        if (e.getOperation().equals("+")){                            vertex.value = value1 + value2;                        }                    }                }            }            return String.valueOf(vertexMap.get("R").value);        }else{            return "ERROR";        }    }    /**     * This method uses topological sort to get the order to estimate the value of "R".     */    public void topSort(){        for (Vertex v: vertices) {            v.setInDegree();            if (v.inDegree == 0){                queue.push(v);            }        }        while(!queue.isEmpty()) {            Vertex current = queue.poll();            topOrder.add(current);            for (Vertex child : current.children) {                child.inDegree -= 1;                if (child.inDegree == 0) {                    queue.push(child);                }            }        }    }}