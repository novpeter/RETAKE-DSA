import java.util.ArrayList;import java.util.HashMap;import java.util.PriorityQueue;/** * Created by Petr on 18.04.2017. */public class Graph {    HashMap<String, Vertex> map;    ArrayList<Edge> edges;    ArrayList<Vertex> vertices;    ArrayList<Vertex> visited;    final double INFINITY = 1000000000;    HashMap<String, Entry> pqMap = new HashMap<>();    PriorityQueue<Entry> pq;    public Graph() {        map = new HashMap<>();        edges = new ArrayList<>();        vertices = new ArrayList<>();    }    /**     * This method adds new edge to the edge list.     * @param v - name of vertex     * @param w - name of the another vertex     * @param dist - distance     * @param time - time     * @param cost - cost     */    public void addEdge(String v, String w, double dist, double time, double cost) {        if (map.containsKey(v) && map.containsKey(v) && !areAdjacent(v,w)) {            Vertex v1 = map.get(v);            Vertex v2 = map.get(w);            Edge edge = new Edge(v1, v2, dist, time, cost);            edges.add(edge);            v1.incidentEdges.add(edge);            v2.incidentEdges.add(edge);            v2.adjacencyVertex.add(v1);            v1.adjacencyVertex.add(v2);        }    }    /**     * This method adds new vertex to the vertex list.     * @param name - name of the new vertex.     */    public void addVertex(String name) {        if (!map.containsKey(name)) {            Vertex vertex = new Vertex(name);            map.put(name, vertex);            vertices.add(vertex);        }    }    /**     * This method returns the array of two vertices which form an edge.     * @param e Edge     * @return ArrayList of vertices     */    public ArrayList<Vertex> endVertices(Edge e){        return e.endVertices;    }    /**     * This method returns if two vertices are adjacent     * @param v vertex     * @param w vertex     * @return true/false     */    public boolean areAdjacent(Vertex v, Vertex w){        return v.adjacencyVertex.contains(w);    }    /**     * This method returns if two vertices are adjacent     * @param name1 - name of the first vertex     * @param name2 - name of the second vertex     * @return true/false     */    public boolean areAdjacent(String name1, String name2){        Vertex v = map.get(name1);        Vertex w = map.get(name2);        return v.adjacencyVertex.contains(w);    }    /**     * This method returns degree of the vertex     * @param v - given vertex     * @return degree     */    public int degree(Vertex v){        return v.incidentEdges.size();    }    /**     * This method returns degree of the vertex     * @param name  - name of the given vertex     * @return degree     */    public int degree(String name){        Vertex v = map.get(name);        return v.incidentEdges.size();    }    /**     * This method removes Vertex from the graph, also removes this vertex form every "adjacencyVertex" list.     * @param v - given vertex     */    public void removeVertex(Vertex v){        for (Edge e : v.incidentEdges) {            e.opposite(v).adjacencyVertex.remove(v);            e.opposite(v).incidentEdges.remove(e);            edges.remove(e);        }        vertices.remove(v);        map.remove(v.getName());    }    /**     * This method removes Vertex from the graph, also removes this vertex form every "adjacencyVertex" list.     * @param name - name of the given vertex     */    public void removeVertex(String name){        Vertex v = map.get(name);        map.remove(name);        for (Edge e : v.incidentEdges) {            e.opposite(v).adjacencyVertex.remove(v);            e.opposite(v).incidentEdges.remove(e);            edges.remove(e);        }        vertices.remove(v);    }    /**     * This method removes Edge from the graph, also removes this edge from every "incidentEdge" lists     * @param e - given edge     */    public void removeEdge(Edge e){        for (Vertex v : e.endVertices) {            v.incidentEdges.remove(e);            v.adjacencyVertex.remove(e.opposite(v));        }        edges.remove(e);    }    /**     * This method provides dijkstra algorithm to find the fastest path.     * @param s - start     */    private void dijkstraAlgorithm(String s){        Vertex start = map.get(s);        //Firstly fill all "Entry" objects with vertex, time, cost and previous vertex.        for (Vertex v : vertices) {            if (v.equals(start)){                Entry entry = new Entry(v, 0,0, null);                pq.add(entry);                pqMap.put(v.getName(), entry);            }else{                Entry entry = new Entry(v, INFINITY, 0, null);                pq.add(entry);                pqMap.put(v.getName(), entry);            }        }        /*While algorithm don't visit every vertex, do next steps:        -Take a vertex with minimum time from the table (priority queue) - current vertex.        -For each adjacent vertex, if it isn't visited, update time and previous_vertex values, according to the current vertex.        -Put current vertex into "visited" set.        */        while (visited.size() != vertices.size()){            Vertex current = pq.poll().vertex;            for (Edge e: current.incidentEdges){                Vertex opposite = e.opposite(current);                if (!visited.contains(opposite)){                    Entry entry = pqMap.get(opposite.getName());                    if (entry.time > e.getTime()+ pqMap.get(current.getName()).time) {                        entry.previous_vertex = current; //update previous_vertex                        entry.cost = e.getCost() + pqMap.get(current.getName()).cost;                        entry.time = e.getTime() + pqMap.get(current.getName()).time; //update time value                        pq.remove(entry);                        pq.add(entry);                    }                }            }            visited.add(current);        }    }    /**     * This method returns result string with next information:     * "start" "destination" "weight" "time" "delivery cost".     * To compute delivery time and cost, it uses Dijkstra algorithm.     * @param s - start     * @param d - destination     * @param w - weight     * @return result     */    public String fastestPath(String s, String d, double w){        visited = new ArrayList<>();        pq = new PriorityQueue<>((Entry e1, Entry e2) -> (e1.time > e2.time) ? 1 : -1);        dijkstraAlgorithm(s);        return (s + " " + d + " " + w + " " + String.format("%.1f", pqMap.get(d).time) + " " + String.format("%.1f", pqMap.get(d).cost * w));    }}